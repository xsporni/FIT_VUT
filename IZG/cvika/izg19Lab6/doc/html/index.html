<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Izg 2018 - 2019, lab 6.: Izg 2017 - 2019, cvičení 6.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Izg 2018 - 2019, lab 6.
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Izg 2017 - 2019, cvičení 6. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#zadani">Zadání cvičení 6. do předmětu IZG 2018 - 2019.</a></li>
<li class="level1"><a href="#teorie">Teorie</a><ul><li class="level2"><a href="#terminologie">Terminologie</a></li>
</ul>
</li>
<li class="level1"><a href="#glsl">Jazyk GLSL</a></li>
<li class="level1"><a href="#sestaveni">Sestavení</a></li>
<li class="level1"><a href="#spousteni">Spouštění</a></li>
<li class="level1"><a href="#ovladani">Ovládání</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="zadani"></a>
Zadání cvičení 6. do předmětu IZG 2018 - 2019.</h1>
<p>Vašim úkolem je naimplementovat phongův osvětlovací model pomocí OpenGL. Úkol je složen ze tří částí:</p><ul>
<li>Inicializace dat na GPU a spuštění kreslení <a class="el" href="group__task1.html">první úkol </a>. <div class="image">
<img src="task1.png" alt="task1.png"/>
<div class="caption">
Výstup po prvním úkolu</div></div>
</li>
<li>Implementace transformace vrcholů pomocí vertex shaderu <a class="el" href="group__task2.html">druhý úkol </a>. <div class="image">
<img src="task2.png" alt="task2.png"/>
<div class="caption">
Výstup po druhém úkolu</div></div>
</li>
<li>Implementace phongova osvětlení pomocí fragment shaderu <a class="el" href="group__task3.html">třetí úkol </a>. <div class="image">
<img src="task3.png" alt="task3.png"/>
<div class="caption">
Výstup cvičení</div></div>
 Seznam všech úkolů naleznete zde <a class="el" href="todo.html">todo.html</a>.</li>
</ul>
<p>Ve cvičení se seznámíte se základními funkcemi OpenGL a napíšete si jednoduchý kód ve jazyce GLSL. Prerekvizita cvičení je 11. přednáška o osvětlování a základech OpenGL. Cvičení taktéž kopíruje zadání projektu, ve kterém je úkol totožný, ale nevyužívá se OpenGL.</p>
<p>V projektu je přítomen i příklad vykreslení jednoho čtverce: v <a class="el" href="quadExample-example.html">Quad Example</a>. Tento příklad můžete využít pro inspiraci a návod jak napsat cvičení, musíte však zaměnit některé funkce za tzv. Direct State Access (DSA) alternativy (NUTNÉ POUŽÍVAT MIN. OPENGL 4.5). Všechny principy OpenGL, které budete ve cvičení používat jsou tam použity (tvorba bufferů, tvorba vertex arrays objektu, indexování, uniformní proměnné, vertex atributy, přeposílání dat mezi vertex shaderem a fragment shaderem).</p>
<p>Všechny úkoly jsou v souboru <b><a class="el" href="student_8c.html" title="This file contains implementation of exercise. ">student/student.c</a></b>. Model králička je v souboru <b><a class="el" href="model_8h.html" title="This file contains a 3D model in static arrays. ">student/model.h</a></b>.</p>
<h1><a class="anchor" id="teorie"></a>
Teorie</h1>
<p>Typické grafické API (OpenGL/Vulkan/DirectX) je složeno ze 2 částí: CPU a GPU strany.</p>
<p>CPU strana se obvykle stará o tyto úkoly:</p><ul>
<li>Příprava dat pro kreslení (modely, textury, matice, ...)</li>
<li>Upload dat na GPU a nastavení GPU</li>
<li>Spuštění vykreslení</li>
</ul>
<p>GPU strana je složena ze dvou částí: video paměti a zobrazovacího řetězce. Vykreslovací řetězec se skládá z několika částí:</p><ul>
<li>Vertex Puller</li>
<li>Vertex Processor</li>
<li>Primitive Assembly</li>
<li>Clipping</li>
<li>Rasterize</li>
<li>Fragment Processor</li>
<li>Per-Fragment Operations</li>
</ul>
<h2><a class="anchor" id="terminologie"></a>
Terminologie</h2>
<p><b>Vertex</b> je kolekce několika vertex atributů. Tyto atributy mají svůj typ a počet komponent. Každý vertex atribut má nějaký význam (pozice, hmotnost, texturovací koordináty), které mu přiřadí programátor/modelátor. Z několika vrcholů je složeno primitivum (trojúhelník, úsečka, ...)</p>
<p><b>Vertex atribut</b> je jedna vlastnost vrcholu (pozice, normála, texturovací koordináty, hmotnost, ...). Atribut je složen z 1,2,3 nebo 4 komponent daného typu (FLOAT, INT, ...). Sémantika atributu není pevně stanovena (atributy mají pouze pořadové číslo - attribIndex) a je na každém programátorovi/modelátorovi, jakou sémantiku atributu přidělí. </p><div class="image">
<img src="primitive.svg" alt="primitive.svg"/>
<div class="caption">
Vertex attributes</div></div>
<p> <b>Fragment</b> je kolekce několika atributů (podobně jako Vertex). Tyto atributy mají svůj typ a počet komponent. Fragmenty jsou produkovány resterizací, kde jsou atributy fragmetů vypočítány z vertex atributů pomocí interpolace. Fragment si lze představit jako útržek původního primitiva.</p>
<p><b>Fragment atribut</b> je jedna vlastnost fragmentu (podobně jako vertex atribut).</p>
<p><b>Interpolace</b> Při přechodu mezi vertex atributem a fragment atributem dochází k interpolaci atributů. Atributy jsou váhovány podle pozice fragmentu v trojúhelníku (barycentrické koordináty). </p><div class="image">
<img src="interpolation.svg" alt="interpolation.svg"/>
<div class="caption">
Vertex attribute interpolation</div></div>
<p> <b>Vertex Processor</b> (často označován za Vertex Shader) je funkční blok, který je vykonáván nad každým vertexem. Jeho vstup i výstup je Vertex. Výstupní vertex má obvykle jiné vertex atributy než vstupní vertex. Výstupní vertex má vždy atribut - gl_Position (pozice vertexu v clip-space). Vertex Processor se obvykle stará o transformace vrcholů modelu (posuny, rotace, projekce). Jelikož Vertex Processor pracuje po vrcholech, je vhodný pro efekty jako vlnění na vodní hladině, displacement mapping apod. Vertex Processor má informace pouze o jednom vrcholu v daném čase (neví nic o sousednostech vrcholů). Vertex processor je programovatelný.</p>
<p><b>Fragment Processor</b> (často označován za Fragment Shader/Pixel Shader) je funkční blok, který je vykonáván nad každým fragmentem. Jeho vstup i výstup je Fragment. Výstupní fragment má obykle jiné attributy. Fragment processor je programovatelný.</p>
<p><b>Shader</b> je program/funkce, který běží na některé z programovatelných částí zobrazovacího řetezce. Shader má vstupy a výstupy, které se mění s každou jeho invokací. Shader má také vstupy, které zůstávají konstantní a nejsou závislé na číslu invokace shaderu. Shaderů je několik typů, v tomto projektu se používají pouze 2 - vertex shader a fragment shader. V tomto projektu jsou shadery reprezentovány pomocí standardních Cčkovských funkcí.</p>
<p><b>Vertex Shader</b> je program, který běží na vertex processoru. Jeho vstupní interface obsahuje: vertex, uniformní proměnné a další proměnné (číslo vrcholu gl_VertexID, ...). Jeho výstupní inteface je vertex, který vždy obsahuje proměnnou gl_Position - pozici vertexu v clip-space.</p>
<p><b>Fragment Shader</b> je program, který běží na fragment processoru. Jeho vstupní interface obsahuje: fragment, uniformní proměnné a proměnné (souřadnici fragmentu ve screen-space gl_FragCoord, ...). Jeho výstupní interface je fragment.</p>
<p><b>Shader Program</b> je kolekce programů, které běží na programovatelných částech zobrazovacího řetězce. Obsahuje vždy maximálně jeden shader daného typu. V tompto projektu je program reprezentován pomocí dvou ukazatelů na funkce. </p><div class="image">
<img src="shader_program.svg" alt="shader_program.svg"/>
<div class="caption">
This shader program is composed of vertex shader and fragment shader</div></div>
<p> <b>Buffer</b> je lineární pole dat ve video paměti na GPU. Do bufferů se ukládají vertex attributy vextexů modelů nebo indexy na vrcholy pro indexované vykreslování. Buffer je na CPU straně reprezentování celočíselným identifikátorem.</p>
<p><b>Binding point</b> je místo, kam lze připojit buffer. Některé binding pointy slouží pro indexování, jiné pro vertex atributy.</p>
<p><b>Uniformní proměnná</b> je proměná uložená v konstantní paměti GPU. Všechny programovatelné bloky zobrazovacího řetězce z nich mohou pouze číst. Jejich hodnota zůstává stejná v průběhu kreslení (nemění se v závislosti na číslu vertexu nebo fragmentu). Jejich hodnodu lze změnit z CPU strany pomocí funkcí jako je glUniform1f, glUniform1i, glUniform2f, glUniformMatrix4fv apod. Uniformní proměnné jsou vhodné například pro uložení transformačních matic nebo uložení času.</p>
<p><b>Vertex Puller</b> se stará o přípravů vrcholů. K tomuto účelu má tabulku s nastavením (vertex arrays object). Vertex puller si můžete představit jako sadu čtecích hlav. Každá čtecí hlava se stará o přípravu jednoho vertex atributu. Mezi nastavení čtecí hlavy patří: ukazatel na začátek bufferu, offset a krok. Vertex puller může obsahovat indexování.</p>
<p><b>Vertex Arrays Object (VAO)</b> je tabulka s nastavením vertex pulleru. Obsahuje seznam nastavení čtecích hlav pro jednotlivé vertex atributy.</p>
<p><b>Zobrazovací řetězec</b> je obvykle kus hardware na grafické kartě, který se stará o vyreslování. Grafická karta je složena ze dvou částí: paměti a zobrazovacího řetězce. V paměti se nacházejí buffery, textury, uniformní proměnné, programy, nastavení vertex pulleru a framebuffery. Pokud se spustí kreslení N vrcholů, je vertex puller spuštěn N krát a sestaví N vrcholů. Nad každým vrcholem je puštěn vertex shader. Výstupem vertex shaderu je nový vrchol. Blok sestavení primitiv "si počká" na 3 vrcholy z vertex shaderu (pro trojúhelník) a vloží je do jedné struktury. Blok clipping ořeže trojúhelníky pohledovým jehlanem. Následuje perspektivní dělení, které vydělí pozice vertexů homogenní složkou. Poté následuje viewport transformace, která podělené vrcholy transformuje do rozlišení obrazovky. Rasterizace trojúhelníky nařeže na fragmenty a interpoluje vertex atributy. Nad každým fragmentem je spuštěn fragment shader. Než jsou fragmenty zapsány zpět do paměti GPU (framebufferu) jsou provedeny per-fragment operace (zjištění viditelnosti fragmentů podle hloubky uchované v depth bufferu). </p><div class="image">
<img src="rendering_pipeline.svg" alt="rendering_pipeline.svg"/>
<div class="caption">
Simplified rendering pipeline</div></div>
<p> <b>Uniformní lokace</b> je číslo, které reprezentuje jednu uniformní proměnnou.</p>
<p><b>Vertex atribut lokace</b> je číslo, které reprezentuje jeden vertex atribut.</p>
<p><b>gl_VertexID</b> je číslo vrcholu, které je vypočítáno pomocí indexování a pořadového čísla vyvolání vertex shaderu.</p>
<p><b>Indexované kreslení</b> je způsob snížení redundance dat s využitím indexů na vrcholy. </p><div class="image">
<img src="drawElements.svg" alt="drawElements.svg"/>
<div class="caption">
Difference between indexed and non-indexed drawing</div></div>
 <h1><a class="anchor" id="glsl"></a>
Jazyk GLSL</h1>
<p>Jazyk GLSL slouží pro implementaci algoritmů (shader programů), které běží na grafické kartě. Jazyk je odvozen z jazyka C a je rozšířen o vektorové a maticové typy: </p><pre class="fragment">* vec3 a;//vektor třísložkový, typ float
* ivec4 b;//vektor čtyřsložkový, typ int
* mat4 c;//matice 4x4, typ float
* </pre><p> Jazyk má přetížené operátory a funkce pro práci s těmito novými typy: </p><pre class="fragment">* vec3 a = vec3(1,2,3);
* vec3 b = vec3(2,3,2);
* b += a;//pricte k "b" "a" po komponentách
* b.x = 10;//nahraje do x složky 10
* b[1] = 11;//nahraje do y složky 11
* b.xy = vec2(13,14);//nahraje do x 13 a do y 14
* b = a.xxy;// je akvivalentni k b.x = a.x; b.y = a.x; b.z = a.y;
* float s = dot(a,b);//skalární součin
* b *= 10;//vynásobí všechny složky vektoru 10
* mat3 m;
* b = m*a;//násobení maticí
* </pre><p> Jazyk vynucuje, aby první řádek zdrojového kódu obsahoval verzi </p><pre class="fragment">* #version 450
* </pre><p> Zdrojový kód shaderu je složen z interface a funkce main. Interface obsahuje deklarace globálních proměnných, pomocí kterých shader komunikuje s okolím. Funkce main je vykonána nad každým vertexem/fragmentem. Kvalifikátor proměnné "uniform" říká, že data proměnné budou uložena v konstantní paměti GPU, která lze změnit z CPU. </p><pre class="fragment">* uniform mat4 viewMatrix;
* </pre><p> Kvalifikátor "in" a "out" říkají, že data proměnné přijdou z předcházejícího programovatelného bloku nebo vertex pulleru nebo odejdou do následujícího programovatelného bloku nebo do per-fragment operací. Lokaci lze získat pouze z uniformních proměnných a "in" proměnných vertex shaderu. Takto dekorované proměnné mění svoji hodnotu per-vertex nebo per-fragment. Jazyk obsahuje spoustu vestavěnách funkcí: </p><pre class="fragment">* vec3 a,b;
* dot(a,b);//skalární součin
* cross(a,b);//cross product
* reflect(a,b);//a je odražen podle b
* normalize(a);//normalizace
* clamp(f,a,b) ořez proměnné f do rozsahu [a,b]
* min(a,b) návrat menší hodnoty
* max(a,b) návrat větší hodnoty
* </pre><h1><a class="anchor" id="sestaveni"></a>
Sestavení</h1>
<p>Linux v CVT: pustit skript linux_create_makefile.sh - to vám vytvoří makefile ve složce build Postup:</p><ol type="1">
<li>$ ./linux_create_makefile.sh</li>
<li>$ cd build</li>
<li>$ make</li>
</ol>
<p>Windows: V CVT je naistalována stará verze CMake, stáhněte <b>novou</b> verzi CMake z: <a href="http://www.fit.vutbr.cz/~imilet/shared/cmake-3.11.1-win64-x64.zip">cmake na kazi</a>, nebo z <a href="https://cmake.org/files/v3.11/cmake-3.11.1-win64-x64.zip">CMAKE</a>. Rozbalte cmake a spusťte program <b>bin/cmake-gui.exe</b>. </p><div class="image">
<img src="64build.png" alt="64build.png"/>
<div class="caption">
sestavení v CVT</div></div>
<p> Cvičení bylo testováno na Ubuntu 14.04, Ubuntu 16.04, Visual Studio 2013, Visual Studio 2015, Visual Studio 2017. Cvičení vyžaduje 64 bitové sestavení. Cvičení využívá build systém <a href="https://cmake.org/">CMAKE</a>. CMake je program, který na základně konfiguračních souborů "CMakeLists.txt" vytvoří "makefile" v daném vývojovém prostředí. Dokáže generovat makefile pro Linux, mingw, solution file pro Microsoft Visual Studio, a další. Pro Visual Studio 2017 je potřeba nový CMAKE 3.10.1 a vyšší. Postup:</p><ol type="1">
<li>stáhnout projekt</li>
<li>rozbalit projekt</li>
<li>ve složce build spusťte "cmake-gui .." případně "ccmake .."</li>
<li>vyberte si překladovou platformu (64 bit).</li>
<li>configure</li>
<li>generate</li>
<li>make nebo otevřete vygenerovnou Microsoft Visual Studio Solution soubor.</li>
</ol>
<p>Cvičení vyžaduje pro sestavení knihovnu <a href="https://www.libsdl.org/download-2.0.php">SDL2</a>. Ta je pro 64bit build ve Visual Studiu přibalena. Cesty na hlavičkové soubory a libs jsou nastaveny pomocí checkboxu USE_PREBUILD_LIB_PACKAGE. Pod Linuxem si stáhněte SDL2 zdrojáky, zkompilujte je (s pomocí CMAKE) a nainstalujte knihovnu.</p>
<h1><a class="anchor" id="spousteni"></a>
Spouštění</h1>
<p>Cvičení je možné po úspěšném přeložení pustit přes aplikaci <b>izg2017Lab6</b>.</p>
<h1><a class="anchor" id="ovladani"></a>
Ovládání</h1>
<p>Program se ovládá pomocí myši a klávesnice:</p><ul>
<li>stisknuté levé tlačítko myši + pohyb myší - rotace kamery</li>
<li>stisknuté pravé tlačítko myši + pohyb myší - přiblížení kamery</li>
<li>"n" - přepne na další scénu/metodu "p" - přepne na předcházející scénu/metodu </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 24 2019 08:37:08 for Izg 2018 - 2019, lab 6. by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
